<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kotlin笔记 | Migu'Blog|迷毂</title><meta name="author" content="migu"><meta name="copyright" content="migu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 变量val表示不可变变量，初始赋值之后不可变（Java中的final） var表示可变变量，允许重新赋值 对于延迟赋值，Kotlin无法提供类型推断，需要显式的声明类型 1var a:Int &#x3D; 10  需要注意：Kotlin完全抛弃了基本数据类型，全部改用了对象数据类型，因此类型关键字开头为大写 如果我们需要获取类属性，可以为其添加一个get()函数实现getter，比如下面的类属性">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin笔记">
<meta property="og:url" content="https://migu316.github.io/2023/12/27/Android/Kotlin%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Migu&#39;Blog|迷毂">
<meta property="og:description" content="[TOC] 变量val表示不可变变量，初始赋值之后不可变（Java中的final） var表示可变变量，允许重新赋值 对于延迟赋值，Kotlin无法提供类型推断，需要显式的声明类型 1var a:Int &#x3D; 10  需要注意：Kotlin完全抛弃了基本数据类型，全部改用了对象数据类型，因此类型关键字开头为大写 如果我们需要获取类属性，可以为其添加一个get()函数实现getter，比如下面的类属性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lc-zp9lzzl0.cn-n1.lcfile.com/EgIh7nP97s2Iva0odX4lINSstzjXQGHa/favicon.png">
<meta property="article:published_time" content="2023-12-27T08:07:30.000Z">
<meta property="article:modified_time" content="2024-02-21T07:28:33.163Z">
<meta property="article:author" content="migu">
<meta property="article:tag" content="Kotlin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lc-zp9lzzl0.cn-n1.lcfile.com/EgIh7nP97s2Iva0odX4lINSstzjXQGHa/favicon.png"><link rel="shortcut icon" href="http://lc-zp9lZZL0.cn-n1.lcfile.com/EgIh7nP97s2Iva0odX4lINSstzjXQGHa/favicon.png"><link rel="canonical" href="https://migu316.github.io/2023/12/27/Android/Kotlin%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kotlin笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-21 15:28:33'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://lc-zp9lZZL0.cn-n1.lcfile.com/EgIh7nP97s2Iva0odX4lINSstzjXQGHa/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/HTML/%E7%85%A7%E7%89%87BootStrap/index.html"><i class="fa-fw fa fa-globe"></i><span> 潼南Bootstrap</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Migu'Blog|迷毂"><span class="site-name">Migu'Blog|迷毂</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/HTML/%E7%85%A7%E7%89%87BootStrap/index.html"><i class="fa-fw fa fa-globe"></i><span> 潼南Bootstrap</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Kotlin笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-27T08:07:30.000Z" title="发表于 2023-12-27 16:07:30">2023-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-21T07:28:33.163Z" title="更新于 2024-02-21 15:28:33">2024-02-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kotlin/">Kotlin</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Kotlin笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>[TOC]</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><p><code>val</code>表示不可变变量，初始赋值之后不可变（Java中的final）</p>
<p><code>var</code>表示可变变量，允许重新赋值</p>
<p>对于延迟赋值，Kotlin无法提供类型推断，需要显式的声明类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a:Int = 10</span><br></pre></td></tr></table></figure>

<p>需要注意：Kotlin完全抛弃了基本数据类型，全部改用了对象数据类型，因此类型关键字开头为大写</p>
<p>如果我们需要获取类属性，可以为其添加一个<code>get()</code>函数实现<code>getter</code>，比如下面的类属性，我们添加了一个getter访问器，由<code>questionBank[currentIndex].answer </code>提供值，返回给<code>get()</code>函数，再由<code>get()</code>函数进行返回</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QuizViewModel</span> : <span class="type">ViewModel</span>() &#123; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> currentIndex = <span class="number">0</span> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> questionBank = listOf( </span><br><span class="line">        ... </span><br><span class="line">    ) </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">val</span> currentQuestionAnswer: <span class="built_in">Boolean</span> </span><br><span class="line">        <span class="keyword">get</span>() = questionBank[currentIndex].answer </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a><strong>自定义函数</strong></h3><p>Kotlin支持自定义函数，格式如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodName</span><span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过传递一个val变量后，在函数中进行修改，可以发现无法修改，因此Kotlin使用的应该也是引用传递</p>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a><strong>语法糖</strong></h3><p>对于只有一行代码的情况下，Kotlin允许我们不必编写函数体，将唯一的代码写在函数定义的尾部，使用<code>=</code>连接</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumberSugar</span><span class="params">(param1: <span class="type">Int</span>, param2 : <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = max(num1, num2)</span><br></pre></td></tr></table></figure>

<p>得益于类型推断，在上面这种情况下，我们可以不写返回类型，因为通过一行代码的返回值，足以推断出返回值的类型，因此可以简化为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumberSugar</span><span class="params">(param1: <span class="type">Int</span>, param2 : <span class="type">Int</span>)</span></span> = max(num1, num2)</span><br></pre></td></tr></table></figure>

<h2 id="程序的逻辑控制"><a href="#程序的逻辑控制" class="headerlink" title="程序的逻辑控制"></a><strong>程序的逻辑控制</strong></h2><h3 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a><strong>if条件语句</strong></h3><p>Kotlin 中的 if 语句和 Java 中的 if 语句几乎没有任何区别，但是会有一些不同点</p>
<p>if语句可以有返回值，返回值就是if语句每一个条件中最后一行代码的返回值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> value = <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">    num1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<p>上面的代码还可以继续简写:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">    num1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用语法糖，能够将上面的代码进一步精简，虽然下面的代码不止一行，但是功能都是相同的，都是返回了 if 的返回值而已，符合使用语法糖的使用条件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumberOfIfSugar</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">    num1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续精简掉括号</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumberOfIfSugar2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (num1 &gt; num2) num2 <span class="keyword">else</span> num2</span><br></pre></td></tr></table></figure>

<h3 id="when条件语句"><a href="#when条件语句" class="headerlink" title="when条件语句"></a><strong>when条件语句</strong></h3><p>when 条件语句主要是解决 Java 中 swich 语句的痛点，不过有一些问题已经在 JDK17 中支持并转正或预览</p>
<p>如果我们需要输入名字找到对应学生的成绩，使用 if 语句需要如下使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">if</span> ( name == <span class="string">&quot;tom&quot;</span>) &#123;</span><br><span class="line">    <span class="number">86</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( name == <span class="string">&quot;Jim&quot;</span>) &#123;</span><br><span class="line">    <span class="number">77</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( name == <span class="string">&quot;Jack&quot;</span>) &#123;</span><br><span class="line">    <span class="number">95</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( name == <span class="string">&quot;Lily&quot;</span>) &#123;</span><br><span class="line">    <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于判断条件非常多的情况，可以使用 when 语句</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScoreByWhen</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> (name) &#123;</span><br><span class="line">    <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span></span><br><span class="line">    <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">77</span></span><br><span class="line">    <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">95</span></span><br><span class="line">    <span class="string">&quot;Lily&quot;</span> -&gt; <span class="number">100</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了精确匹配，还可以进行类型匹配， is 关键字是类型匹配的核心，它相当于 Java 中更多 instanceof 关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(num: <span class="type">Number</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (num) &#123;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;number is Int&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Double</span> -&gt; println(<span class="string">&quot;number is double&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;number not support&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>number</code>类型：是Kotlin内置的一个抽象类，Int 、Long 、Float、Double 等与数字相关的类型都是它的子类</p>
<p>when 语句还有一种不带参数的写法，虽然不常用，但是可以发挥很强的拓展性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScoreByWhenNotParam</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line">    name == <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span></span><br><span class="line">    name == <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">77</span></span><br><span class="line">    name == <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">95</span></span><br><span class="line">    name == <span class="string">&quot;Lily&quot;</span> -&gt; <span class="number">100</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现在Kotlin中判断字符串对象是否相等可以直接使用 <code>==</code>关键字，而不用像 Java 那样调用 equals() 方法</p>
<p>现在有一个需求，假设名字以 Tom 开头的人，分数都是86，这种场景就不能使用带参数的 when 来实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScoreByWhenNotParamTom</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line">    name.startsWith(<span class="string">&quot;Tom&quot;</span>) -&gt; <span class="number">86</span></span><br><span class="line">    name == <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">77</span></span><br><span class="line">    name == <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">95</span></span><br><span class="line">    name == <span class="string">&quot;Lily&quot;</span> -&gt; <span class="number">100</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>String.startsWith(prefix: String, ignoreCase: Boolean = false): Boolean</code>方法</p>
<p>该方法可以传递一个字符串，用于判断 String 是否以该字符串开头，返回Boolean类型</p>
<p>还有一个可选参数 ignoreCase 默认为 false，用于指定是否要忽略大小写来进行匹配</p>
</blockquote>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a><strong>循环语句</strong></h3><p>Kotlin 中的 while 循环和 Java 中没有任何区别</p>
<p>但是对于 for 循环却做了很大的修改，Java 中的 for-i循环被舍弃，但是 for-each 被大幅增强，变成了 for-in 循环。</p>
<blockquote>
<p>Kotlin中引入了区间，使用 <code>..</code>关键字，表示创建两端闭合的区间</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">0.</span><span class="number">.10</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>有了区间后，我们可以使用 for-in 来遍历这个区间</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">applyForIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>既然有双端闭合区间，那么肯定也有单端闭合区间，使用 until 关键字创建一个左闭右开的区间</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rangeUntil = <span class="number">0</span> until <span class="number">10</span> </span><br></pre></td></tr></table></figure>

<p>IDE提示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rangeUntil = <span class="number">0.</span>.&lt;<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p> 可以修改为这种实现</p>
</blockquote>
<p>for-in 循环每次执行的时候，每次执行都会在区间范围内递增1，如果想跳过一些元素，可以使用 step 关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> rangeUntil step <span class="number">2</span>) println(i)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果如下：</p>
<p>0<br>2<br>4<br>6<br>8</p>
</blockquote>
<blockquote>
<p>对于 <code>..</code>和<code>until</code>关键字都要求区间的左端小于等于区间的右端，也就是一个升序的区间，如果要创建一个降序的区间，可以使用 <code>downTo</code> 关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span>) println(i)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><strong>面向对象</strong></h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a><strong>类与对象</strong></h3><p>Kotlin中新建一个类，代码如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating. He is <span class="variable">$age</span> years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于类的实例化，不需要使用 new 关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = Person()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特性：Kotlin中任何一个非抽象类默认是不可以被继承的，相当于 Java 中给类声明了 final 关键字</p>
<p>如果需要让类变得可被继承，需要使用 <code>open</code> 关键字在需要被继承的类的前面</p>
</blockquote>
<h3 id="主构造函数和次构造函数"><a href="#主构造函数和次构造函数" class="headerlink" title="主构造函数和次构造函数"></a><strong>主构造函数和次构造函数</strong></h3><p> 子类的主构造函数调用哪个父类中的哪个构造函数，在继承的时候跳过括号来指定</p>
<p>1.未实现主构造函数，会有一个默认的无参主构造函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建一个类继承Person的时候，如果Person是默认的无参主构造函数，那么下面的代码也调用的是无参主构造函数，其中Person()代表调用无参主构造函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> :<span class="type">Person</span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.当我们把 Person 的主构造函数修改，就已经没有无参主构造函数了，因此子类无法通过 Person() 这种方式去调用父类的主构造函数，而是需要传递参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于子类 Student，有两种方式让子类去调用父类的主构造函数，需要注意，这里传入的参数不可以添加<code>var</code>或者<code>val</code>关键字，当添加了这两个关键字后，参数将会自动称为该类的字段。</p>
<blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(name: String, age: <span class="built_in">Int</span>) : Person(name, age) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>特殊方式：这一种在后面介绍</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> :<span class="type">Person</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name:String, age:<span class="built_in">Int</span>):<span class="keyword">super</span>(name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>3.次构造函数都必须调用主构造函数（包括间接调用）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于下面的次构造函数，通过this调用了主构造函数，第二个次构造函数是间接的调用了主构造函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">private</span> <span class="keyword">val</span> sno: String, <span class="keyword">private</span> <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name:String, age:<span class="built_in">Int</span>) : Person(name, age) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, name, age)</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;Name&quot;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以有3中方法实例化对象了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student1 = Student()</span><br><span class="line"><span class="keyword">val</span> student2 = Student(<span class="string">&quot;Jack&quot;</span>, <span class="number">22</span>)</span><br><span class="line"><span class="keyword">val</span> student3 = Student(<span class="string">&quot;2022520807&quot;</span>, <span class="number">1</span>, <span class="string">&quot;Jack&quot;</span>, <span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p>4.特殊情况：子类中只有次构造函数，没有主构造函数，那么继承的时候就不需要括号了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> :<span class="type">Person</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name:String, age:<span class="built_in">Int</span>):<span class="keyword">super</span>(name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，如果是传递给父类构造方法的参数，是不能添加 <code>val</code> 或 <code>var</code> 关键字的，否则会被认为是该类的字段</p>
</blockquote>
<p><strong>注意</strong></p>
<p>如果我们在Student类中调用Person类的构造方法时，给Person类的构造方法参数传递了默认值，那么将会导致你传递进去的参数不管作用，相当于是被拦截修改了。即下面这种方式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) : Person(name =<span class="string">&quot;tom&quot;</span>, age)</span><br></pre></td></tr></table></figure>

<p>正确的方式应该是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String =<span class="string">&quot;tom&quot;</span>, age: <span class="built_in">Int</span>) : Person(name, age)</span><br></pre></td></tr></table></figure>

<p>通过反编译为Java代码可以发现在最后一次调用Person的构造方法时，通过super传递了那个默认值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String sno, <span class="type">int</span> grade, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;tom&quot;</span>, age);</span><br><span class="line">        <span class="built_in">this</span>.sno = sno;</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, name, age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;DefaultName&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h3><p>Kotlin 中的接口和 Java 中的接口仍是一模一样的，支持多态、默认实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;do homework default implementation.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;Jack&quot;</span>, <span class="number">22</span>)</span><br><span class="line">    doStudy(student)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数的可见性修饰符"><a href="#函数的可见性修饰符" class="headerlink" title="函数的可见性修饰符"></a><strong>函数的可见性修饰符</strong></h3><p>Kotlin 中有4中可见性修饰符：<code>public</code> <code>private</code> <code>protected</code> <code>internal</code></p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20231225193817267.png" alt="image-20231225193817267"></p>
<h2 id="数据类和单例类"><a href="#数据类和单例类" class="headerlink" title="数据类和单例类"></a><strong>数据类和单例类</strong></h2><p><strong>数据类</strong></p>
<p>在 Java 中如果需要对一个类使用 equals 进行比较，往往还需要实现 hashCode() 等方法</p>
<p>在 Kotlin 中只需要将一个类声明为 <code>data</code> 即可，Kotlin 会自动为我们生成这些代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">CellPhone</span>(<span class="keyword">val</span> brand: String, <span class="keyword">val</span> price: <span class="built_in">Double</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cellPhone1 = CellPhone(<span class="string">&quot;三星&quot;</span>, <span class="number">1299.99</span>)</span><br><span class="line">    <span class="keyword">val</span> cellPhone2 = CellPhone(<span class="string">&quot;三星&quot;</span>, <span class="number">1299.99</span>)</span><br><span class="line">    println(cellPhone1)</span><br><span class="line">    println(<span class="string">&quot;cellPhone1 equals cellPhone2 &quot;</span> + (cellPhone1 == cellPhone2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单例类</strong></p>
<p>对于在 Java 中使用单例，往往需要在类中自己实现创建单例的逻辑，在 Kotlin 中只需要将 class 关键字改成 object即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">singletonTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;singletonTest is called&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> singleton = Singleton</span><br><span class="line">singleton.singletonTest()</span><br></pre></td></tr></table></figure>

<p>可以简写为，类似于 Java 中的静态方法的调用方式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton.singletonTest()</span><br></pre></td></tr></table></figure>

<h2 id="Lambda编程"><a href="#Lambda编程" class="headerlink" title="Lambda编程"></a><strong>Lambda编程</strong></h2><h3 id="集合的创建和遍历"><a href="#集合的创建和遍历" class="headerlink" title="集合的创建和遍历"></a><strong>集合的创建和遍历</strong></h3><p>对于 List、Set、Map等接口，都有不同的实现类，在 Kotlin 中可以和 Java相似的创建一个集合对象，然后将数据添加到集合中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = ArrayList&lt;String&gt;()</span><br><span class="line">list.add(<span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Banana&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Orange&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方法比较繁琐，在 Kotlin 中可以使用 listOf 方法来完成不可变集合的创建</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可变集合</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println(fruit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要创建可变集合，需要使用 mutableListOf 方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;WaterMelon&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println(fruit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Set、Map集合，也有一对这样的函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  set集合</span></span><br><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = setOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">    println(fruit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = mutableSetOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>.add(<span class="string">&quot;WaterMelon&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">    println(fruit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Map 集合存储和读取数据可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">map[<span class="string">&quot;Apple&quot;</span>] = <span class="number">1</span></span><br><span class="line">map[<span class="string">&quot;Banana&quot;</span>] = <span class="number">2</span></span><br><span class="line">map[<span class="string">&quot;Orange&quot;</span>] = <span class="number">3</span></span><br><span class="line">map[<span class="string">&quot;Pear&quot;</span>] = <span class="number">4</span></span><br><span class="line">println(map[<span class="string">&quot;Apple&quot;</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;Apple&quot;</span> to <span class="number">1</span>, <span class="string">&quot;Banana&quot;</span> to <span class="number">2</span>, <span class="string">&quot;Orange&quot;</span> to <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> ((fruit, number) <span class="keyword">in</span> map) &#123;</span><br><span class="line">    println(<span class="string">&quot;fruit is <span class="variable">$fruit</span>, number is <span class="variable">$number</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合的函数式API"><a href="#集合的函数式API" class="headerlink" title="集合的函数式API"></a><strong>集合的函数式API</strong></h3><p>Lambda 表达式的语法结构</p>
<blockquote>
<p>{参数名1: 参数类型, 参数名2: 参数类型 -&gt; 函数体}</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lambda = &#123; fruit: String -&gt; fruit.length&#125;</span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy(lambda)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何去理解Lambda表达式呢？</p>
<p>我的理解是实际上把一个函数当作参数传递到了其他函数中，在其他函数中将会调用被传递进去的函数执行一些逻辑；</p>
<p>比如下面这段集合方法的源码，他需要一个函数参数，那么我们调用这个方法<code>list.maxByOrNull &#123;str:String -&gt; str.length&#125;</code>并传递了一段代码进去，这段代码就是lambda表达式，在源码中我们可以看见调用了selector(maxElem)，实际上就是将maxElem传递了进去，然后计算了str.length，并返回了长度，这个selector函数，他的函数体代码实际上就是传递进去的那个lambda表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.4&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R : Comparable&lt;R&gt;</span>&gt; Iterable<span class="type">&lt;T&gt;</span>.<span class="title">maxByOrNull</span><span class="params">(selector: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">val</span> iterator = iterator()</span><br><span class="line">    <span class="keyword">if</span> (!iterator.hasNext()) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> maxElem = iterator.next()</span><br><span class="line">    <span class="keyword">if</span> (!iterator.hasNext()) <span class="keyword">return</span> maxElem</span><br><span class="line">    <span class="keyword">var</span> maxValue = selector(maxElem)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> e = iterator.next()</span><br><span class="line">        <span class="keyword">val</span> v = selector(e)</span><br><span class="line">        <span class="keyword">if</span> (maxValue &lt; v) &#123;</span><br><span class="line">            maxElem = e</span><br><span class="line">            maxValue = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">    <span class="keyword">return</span> maxElem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>简化1：</p>
<blockquote>
<p>不需要单独自定义一个 lambda 变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy(&#123; fruit: String -&gt; fruit.length&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>简化2：</p>
<blockquote>
<p>当 Lambda 参数是函数的最后一个参数，可以将 Lambda表达式移到函数括号的外面</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy()&#123; fruit: String -&gt; fruit.length&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>简化3：</p>
<blockquote>
<p>如果 Lambda 参数是函数的唯一一个参数，可以将函数括号省略</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy&#123; fruit: String -&gt; fruit.length&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>简化4：</p>
<blockquote>
<p>通过 Kotlin 的类型推断，可以将 Lambda 表达式中的参数列表的类型省略</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy&#123; fruit -&gt; fruit.length&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>简化5：</p>
<blockquote>
<p>当 Lambda 表达式的参数列表只有一个参数的时候，不必声明参数名，而是可以使用 <code>it</code> 关键词代替</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy&#123; it.length&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>集合中的 <strong>map 函数</strong>是最常用的一种函数式 API，它用于将集合中的每个元素都映射成一个另外的值，映射规则在 Lambda 表达式中指定，最终生成一个新的集合</p>
<p><code>uppercase</code>可以将单词转换为大写模式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newList = list.map &#123; it.uppercase() &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 filter 函数</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map1 = list.filter &#123; it.length &lt;= <span class="number">5</span> &#125;</span><br><span class="line">    .map &#123; it.uppercase() &#125;</span><br></pre></td></tr></table></figure>

<p>对于使用 lambda 表达式的理解，我的理解是：lambda 表达式可以作为参数，也就是 filter 的判断条件，filter 可以对每一个元素执行 lambda 中的内容，也就是判断是否符合这个条件，Lambda 表达式返回一个布尔值，表示该元素是否符合条件。</p>
<p><strong>any 和 all 函数</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> any = list.any &#123; it.length &lt;= <span class="number">5</span> &#125;</span><br><span class="line"><span class="keyword">val</span> all = list.all &#123; it.length &lt;= <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>any 可以判断集合中是否至少存在一个元素满足指定条件</p>
<p>all 可以判断集合中的所有元素是否满足指定条件</p>
<h3 id="Java-函数式-API-的使用"><a href="#Java-函数式-API-的使用" class="headerlink" title="Java 函数式 API 的使用"></a><strong>Java 函数式 API 的使用</strong></h3><p> 在上面，我们学习了在 Kotlin 中函数式 API 的用法，但实际上在 Kotlin 中调用 Java 方法时也可以使用函数式 API，只不过有一定的条件限制。</p>
<blockquote>
<p>条件：Java 方法需要接收一个 Java 单抽象方法接口参数，就可以使用函数式 API</p>
<p> Java 单抽象方法接口指的是只有一个待实现方法，如果有多个，则无法使用函数式 API</p>
</blockquote>
<p>对于实现一个匿名类，需要使用 object 关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread(<span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;this is thread&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure>

<p>逐步简化1：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable &#123;</span><br><span class="line">        println(<span class="string">&quot;this is thread&quot;</span>)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure>

<p>简化2：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread(&#123;println(<span class="string">&quot;this is thread&quot;</span>)&#125;).start()</span><br></pre></td></tr></table></figure>

<p>简化3：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread&#123;println(<span class="string">&quot;this is thread&quot;</span>)&#125;.start()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>源码分析：</p>
<p>我们直到Android中的控件都是继承自View的，View中有<code>setOnClickListener</code>方法，用于注册点击事件，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnClickListener l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">            setClickable(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnClickListener = l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看见又有一个OnClickListener参数，这个参数实际上是一个接口，在Java中可以通过匿名类的方式去实现。我们查看这个接口的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnClickListener</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Called when a view has been clicked.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> v The view that was clicked.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现该接口有一个待实现的方法，因此我们在Java中我们使用匿名类的方式就需要实现这个接口。</p>
<p>如果在Kotlin中呢，使用Lambda表达式就会简洁很多（Java同样支持），我们传递进一个Lambda对象即可，传递进去的代码将会被默认为onClick(View v)方法的方法体，最后被系统调用。</p>
</blockquote>
<p>本小节学习的 Java 函数式 API 的使用都限定于从 Kotlin 中调用 Java 方法，但抽象方法接口也必须用 Java 语言定义，Kotlin 中有单独的高阶函数来实现自定义函数式 API 功能</p>
<h2 id="空指针检查"><a href="#空指针检查" class="headerlink" title="空指针检查"></a><strong>空指针检查</strong></h2><h3 id="可空类型系统"><a href="#可空类型系统" class="headerlink" title="可空类型系统"></a><strong>可空类型系统</strong></h3><p>Kotlin 默认所有的参数和变量都不可以为空，因此我们无法传递一个为 null 的参数，Kotlin 会在<strong>编译时检查</strong>。</p>
<p>如果我们需要某个参数和变量为空，需要在类型名的后面加上一个 <code>?</code> ，比如 Int 表示不可为空整型，Int? 表示可以为空的整型，如果我们传递了一个可以为空的整型，那么在剩下的代码中就需要对其进行判断处理</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (study != <span class="literal">null</span>) &#123;</span><br><span class="line">        study.readBooks()</span><br><span class="line">        study.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判空辅助工具"><a href="#判空辅助工具" class="headerlink" title="判空辅助工具"></a><strong>判空辅助工具</strong></h3><p>1.使用 <code>?.</code> 操作符优化上面的代码，这个操作符表示如果传递的参数不为空，那么就执行右边的方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study?.readBooks()</span><br><span class="line">    study?.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用 <code>?:</code> 操作符，这个操作符左右两边都可以接收一个表达式，如果左边表达式的结果不为空就返回左边的，否则返回右边表达式结果</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">	a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以简化为</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = a ?: b</span><br></pre></td></tr></table></figure>

<p>详细例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(text: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (text != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> text.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化为:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(text: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> text?.length ?: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次简化：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(text: <span class="type">String</span>?)</span></span> = text?.length ?: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>通过结合 <code>?.</code> 和 <code>?:</code> 操作符，可以简化为上述代码，意思是：如果text不为空执行 length 方法并返回否则返回0，可以这样分割代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(text?.length) ?: (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>使用非空断言工具-断言操作符</strong></p>
<p>对于下面的代码，虽然我们在调用 printUpperCase() 方法的时候做了非空判断，但是在方法中，使用 content变量的时候，Kotlin依然会提示存在空指针异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> content: String? = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (content != <span class="literal">null</span>) &#123;</span><br><span class="line">        printUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> uppercase = content.uppercase()</span><br><span class="line">    println(uppercase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的情况可以使用 <code>!!</code> 操作符，最好别使用断言</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> uppercase = content!!.uppercase()</span><br><span class="line">    println(uppercase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-let-函数"><a href="#使用-let-函数" class="headerlink" title="使用 let 函数"></a><strong>使用 <code>let</code> 函数</strong></h3><p>let 函数可以将原始调用对象作为参数传递到 lambda 表达式中，并且传递进去的对象就是调用 let 函数的对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj.let &#123;</span><br><span class="line">	obj2-&gt;</span><br><span class="line">	<span class="comment">// 具体的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搭配 <code>?.</code> 操作符可以对代码进行优化，我们知道当我们使用 if 语句判断一个参数不为空后，就可以随意调用它的函数，但是当我们只使用 <code>?.</code> 操作符的时候，将其转换为 if 语句就可以看出有些复杂，因为 <code>?.</code> 操作符每次调用都会检查是否为空。而通过搭配 let 函数使用，可以实现一次判断，随意使用 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study?.let&#123;</span><br><span class="line">        it.doHomework()</span><br><span class="line">        it.readBooks()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且 let 函数可以处理全局变量的判空问题，if是无法做到的，比如在下面的代码中，对 study 进行调用是会提示错误的，因为 study 是一个可变的，有可能随时在其他的线程中 study 被更改</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> study:Study? = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (study != <span class="literal">null</span>) &#123;</span><br><span class="line">        study.doHomework()</span><br><span class="line">        study.readBooks()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 let 函数搭配 <code>?.</code> 使用可以避免这个问题，对于传递进来对象，在lambda表达式内部是可以保证安全调用的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    study?.let &#123;</span><br><span class="line">        it.doHomework()</span><br><span class="line">        it.readBooks()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串内嵌表达式"><a href="#字符串内嵌表达式" class="headerlink" title="字符串内嵌表达式"></a><strong>字符串内嵌表达式</strong></h2><p>可以使用 <code>$&#123;student.name + &quot;1&quot;&#125;</code> 这种方式在字符串中内嵌一个表达式，如果只有一个变量的时候，不对这个变量进行操作的时候，可以去掉大括号。</p>
<h2 id="函数的参数默认值"><a href="#函数的参数默认值" class="headerlink" title="函数的参数默认值"></a><strong>函数的参数默认值</strong></h2><p>我们可以给函数的参数设置默认值，比如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">defaultTest</span><span class="params">(age: <span class="type">Int</span>, name: <span class="type">String</span> = <span class="string">&quot;hello&quot;</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个函数的调用可以是</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultTest(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>如果第一个参数设置了默认值，第二个参数没有设2置，在调用函数的时候传递一个 String，就会提示类型不匹配的错误，因为会把参数设置为 age</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">defaultTest</span><span class="params">(age: <span class="type">Int</span> = <span class="number">0</span>, name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过键值对的方式来传参</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultTest(name = <span class="string">&quot;hi&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果有多个参数，先后顺序没有任何影响</p>
<p>因为参数默认值的特性，前面提到次构造函数并不常用，因为可以在主构造函数中设置默认值，传参的时候可以通过键值对的方式进行指定传递。</p>
<h2 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a><strong>标准函数</strong></h2><p>最常见的标准函数有<code>with</code> <code>run</code> <code>apply</code></p>
<p><strong><code>with</code></strong></p>
<blockquote>
<p><strong>参数：</strong></p>
<p>第一个参数可以是任意类型的对象</p>
<p>第二个参数是一个Lambda表达式，在Lambda表达式中可以使用第一个参数对象的上下文</p>
<p><strong>返回：</strong></p>
<p>将会使用Lambda表达式中的最后一行代码作为返回值</p>
<p><strong>例如：</strong></p>
<p><strong>val result &#x3D; with(obj) {</strong></p>
<p>​	<strong>&#x2F;&#x2F; 这里是obj的上下文</strong></p>
<p>​	<strong>“value”	&#x2F;&#x2F; with函数的返回值</strong></p>
<p><strong>}</strong></p>
</blockquote>
<p><strong><code>run</code></strong></p>
<blockquote>
<p>不可以直接调用，需要由某个对象调用</p>
<p><strong>参数</strong></p>
<p>一个Lambda表达式，提供了调用对象的上下文</p>
<p><strong>返回：</strong></p>
<p>将会使用Lambda表达式中的最后一行代码作为返回值</p>
<p><strong>例如:</strong></p>
<p>val result &#x3D;  obj.run {</p>
<p>​	&#x2F;&#x2F; 这里是obj的上下文</p>
<p>​	”value“</p>
<p>}</p>
</blockquote>
<p><code>apply</code></p>
<blockquote>
<p>同样是在某个对象的基础上调用</p>
<p><strong>参数</strong></p>
<p>一个Lambda表达式，提供了调用对象的上下文</p>
<p><strong>返回</strong></p>
<p>返回调用对象本身</p>
<p><strong>例如</strong></p>
<p>val resultObj &#x3D; obj.apply{</p>
<p>​	&#x2F;&#x2F; 这里是obj的上下文</p>
<p>}</p>
<p>&#x2F;&#x2F; resultObj &#x3D; obj</p>
</blockquote>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h2><p>静态方法是指不需要创建实例就可以调用的方法，在Java中只需要给方法加上Static关键字即可。</p>
<p>Kotlin编写静态方法比较复杂，我们可以把它分为</p>
<ul>
<li><p><strong>“虚假”的静态方法</strong></p>
<p>这两种方法实际上是提供了语法特性来支持类似于静态方法调用的写法</p>
<p><strong>1.单例类  object class</strong></p>
<p>​	使用单例类会使得该类中所有的方法都变成了类似于静态方法的调用方式，如果我们只希望类中的一部分方法被调用呢，就需要使用第二种</p>
<p><strong>2.companion object伴生对象</strong></p>
<p>​	这种方式需要在普通类中定义，伴生对象中的方法也不是静态方法，实际上companion object关键字会在外部普通类的内部创建一个伴生类，Kotlin会保证该普通类中只有一个伴生类对象</p>
</li>
<li><p><strong>真正的静态方法</strong></p>
<p><strong>1.注解 @JvmStatic</strong></p>
<p>​	只能在<strong>单例类</strong>和<strong>companion object伴生对象中的方法</strong>添加该注解，Kotlin编译器将会把这些方法编译成真正的静态方法</p>
<p><strong>2.顶层方法</strong></p>
<p>​	比如我们创建一个Helper.kt文件，在里面编写doSomething方法，编译器将会把所有顶层方法编译成静态方法，我们可以直接输出方法名进行调用</p>
<blockquote>
<p>注意，在Java中是无法找到这个方法的，因为Java中没有顶层方法的概念，不过实际上Kotlin在编译顶层方法的时候，会自动创建一个叫做HelperKt的Java类，doSomething方法就是以静态方法的形式定义在该类中，我们可以使用HelperKt.doSomething()的写法进行调用</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a><strong>延迟初始化</strong></h2><p>当我们存在全局变量的时候，有可能该变量需要在其他地方进行初始化，那么就需要使用下面这种方式，可能看见这种方式会导致在其他地方调用时都需要进行判空处理</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> adapter:MyAdapter? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过延时初始化关键字修改，这样在其他地方调用就不用判空处理了，但是需要注意，初始化操作一定要在调用变量前，否则会抛出未初始化的错误</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> adapter:MyAdapter</span><br></pre></td></tr></table></figure>

<p>可以通过<code>::adapter.isInitialized</code>判断是否初始化了，加上<code>!</code>后，就是表明如果没有初始化条件为真</p>
<h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a><strong>密封类</strong></h2><p>假设我们现在有如下接口和实现类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Result</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Success</span>(<span class="keyword">val</span> msg: String) : Result</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failure</span>(<span class="keyword">val</span> error: Exception) : Result</span><br></pre></td></tr></table></figure>

<p>那么我们在对返回结果进行判断的时候，就必须处理三种情况，分别是两个子类，以及一个其他情况，但是else后面的内容永远不会执行，因为Result就只有两个子类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getResultMsg</span><span class="params">(result: <span class="type">Result</span>)</span></span>  = <span class="keyword">when</span>(result) &#123;</span><br><span class="line">    <span class="keyword">is</span> Success -&gt; result.msg</span><br><span class="line">    <span class="keyword">is</span> Failure -&gt; result.error</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalAccessException()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用密封类解决，只需要修改关键字为<code>sealed class</code>，此时编译器会自动检查该密封类有哪些子类，即可保证不用写else</p>
<blockquote>
<p>注意，密封类及其子类只能定义在同一个文件的顶层位置，这是被密封类的底层实现机制所限制。</p>
<p>再就是还可以使用<code>sealed interface</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Success</span>(<span class="keyword">val</span> msg: String) : Result()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failure</span>(<span class="keyword">val</span> error: Exception) : Result()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getResultMsg</span><span class="params">(result: <span class="type">Result</span>)</span></span>  = <span class="keyword">when</span>(result) &#123;</span><br><span class="line">    <span class="keyword">is</span> Success -&gt; result.msg</span><br><span class="line">    <span class="keyword">is</span> Failure -&gt; result.error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a><strong>扩展函数</strong></h2><p>如果我们需要创建一个统计小写字符数的函数，一般情况下我们需要创建一个工具类，然后在里面创建一个静态方法，最后通过调用该方法，传递字符串参数才能完成统计。</p>
<p>但是我们可以通过扩展函数来实现，扩展函数是指可以向任意的类添加我们需要的API</p>
<p>语法结构:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ClassName.<span class="title">methodName</span><span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展String类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lettersCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (ch <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch.isLetter()) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> count = <span class="string">&quot;asdas!@Sd&quot;</span>.lettersCount()</span><br></pre></td></tr></table></figure>



<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a><strong>运算符重载</strong></h2><p>如果我们想直接对任意对象进行运算，那么就可以在对象内部进行运算符重载</p>
<p>使用关键字operator和需要重载的运算符函数</p>
<p>语法结构:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">	<span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(obj : <span class="type">Obj</span>)</span></span>: Obj&#123;</span><br><span class="line">		<span class="comment">// 处理相加的逻辑</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子，可以看见还支持同一个运算符多重重载</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Money</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Money(<span class="keyword">this</span>.value + money.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(newValue: <span class="type">Int</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Money(<span class="keyword">this</span>.value + newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> money = Money(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> money2 = Money(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">val</span> money3 = money + money2</span><br><span class="line"><span class="keyword">val</span> money4 = money + <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>结合前面的扩展函数，我们还可以让系统类支持运算符重载，由于String类型已经支持repeat方法，可以使得字符串重复n次，因此我们重载times，一句话就可以完成扩展重载函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">times</span><span class="params">(n: <span class="type">Int</span>)</span></span> = repeat(n)</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str = <span class="string">&quot;abc&quot;</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>语法糖表达式和实际调用函数对照表</strong></p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240116221114046.png" alt="image-20240116221114046"></p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="定义高阶函数"><a href="#定义高阶函数" class="headerlink" title="定义高阶函数"></a>定义高阶函数</h3><p>如果想要定义自己的函数式API，就可以使用高阶函数来实现</p>
<blockquote>
<p>定义：如果一个函数接收另外一个函数作为参数，或者返回值的类型是另外一个函数，那么这个函数就是高阶函数</p>
<p>函数类型：基本规则<code>(String, Int) -&gt; Unit</code>，前面表示参数列表，后面表示返回值类型，没有返回值就是Unit，类似于Java中的Void</p>
</blockquote>
<p>高阶函数的例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">(<span class="keyword">fun</span>: (<span class="type">String</span>, <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">	func(<span class="string">&quot;hello&quot;</span>, <span class="number">123</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，高阶函数允许让函数类型的参数来决定函数的执行逻辑，即使同一个高阶函数，传入不同的函数类型参数，那么执行逻辑和最终的返回结果也可能完全不同。</p>
<p>比如在下面这个高阶函数中，需要传递两个整型参数，一个函数参数，而函数参数用于计算两个整型参数，因此我们可以传递我们需要的函数参数，比如<code>plus</code> <code>minus</code>等等，最后的结果也不会一样</p>
<blockquote>
<p>传递函数参数，使用<code>::</code>，这是一种函数引用方式的写法</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">num1AndNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    operation(num1, num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num1AndNum2(<span class="number">1</span>, <span class="number">2</span>, ::plus)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以结合Lambda表达式，因为前面提到过，Lambda表达式就是一段代码，在这里就可以理解为一个函数参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1AndNum2(<span class="number">1</span>, <span class="number">2</span>) &#123;n1, n2 -&gt;</span><br><span class="line">    n1 + n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建自己的apply函数"><a href="#创建自己的apply函数" class="headerlink" title="创建自己的apply函数"></a>创建自己的apply函数</h3><p>回顾一下apply的使用，首先StringBuilder可以调用apply方法，然后这个方法中也有StringBuilder的作用域，并且返回了构建好的StringBuilder对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">val</span> string = stringBuilder.apply &#123;</span><br><span class="line">append(<span class="number">111</span>)</span><br><span class="line">      append(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>因此我们的自己的apply方法也需要满足这三个条件，因此我们可以使用扩展方法实现，在下面的实现中，我们首先为StringBuilder扩展了一个build方法，其次传递了一个函数类型的参数，并且这个函数参数同样是一个扩展方法，最后返回了this，也就是当前这个StringBuilder对象。</p>
<blockquote>
<p>为什么传递进去的函数参数也需要是扩展方法呢？</p>
<p>因为我们需要使用在StringBuilder的作用域中，就可以和apply函数一样在lambda表达式中调用StringBuilder的方法</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> StringBuilder.<span class="title">build</span><span class="params">(block: <span class="type">StringBuilder</span>.() -&gt; <span class="type">Unit</span>)</span></span>: StringBuilder &#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数的缺点"><a href="#高阶函数的缺点" class="headerlink" title="高阶函数的缺点"></a>高阶函数的缺点</h3><p>通过将kotlin中的高阶函数的调用转换为Java代码就可以发现，实际上相当于是实现了一个接口，在调用的时候通过匿名内部类的方式进行调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1AndNum2(<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Function</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> num2 + num1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">num1AndNum2</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, Function function)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> function.invoke(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此，这会导致每使用一次Lambda表达式就会带来额外的内存和性能开销。但是可以通过内联函数进行解决</strong></p>
<h3 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h3><p>在高阶函数的定义处添加一个<code>inline</code>关键字即可声明为内联函数，即可避免Lambda表达式带来的运行时开销</p>
<blockquote>
<p>工作原理本质上是一个替换的过程</p>
<p>1.首先将lambda表达式的内容替换到高阶函数的函数参数调用处</p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240118161630648.png" alt="image-20240118161630648"></p>
<p>2.再将高阶函数的全部代码替换到Lambda表达式中函数调用的地方</p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240118161720080.png" alt="image-20240118161720080"></p>
</blockquote>
<p>我们也可以理解为inline不仅可以将内部的函数内联，还会将函数的函数参数，也就是那些lambda表达式全部内联，展开替换到实际调用处，因此就可以避免大量的匿名对象创建导致性能开销</p>
<blockquote>
<p>注意，由于代码替换，可能会导致包大小的增加，尽量在高频调用的函数上使用inline</p>
</blockquote>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240118170134345.png" alt="image-20240118170134345"></p>
<h3 id="关闭内联noinline"><a href="#关闭内联noinline" class="headerlink" title="关闭内联noinline"></a>关闭内联noinline</h3><p>在使用inline时，我们知道函数类型参数将会被内联展开，那么<strong>它将不是一个函数对象</strong>了，我们就<strong>无法将它作为一个对象</strong>来使用（比如当做一个返回值，或者调用toString等方法）</p>
<p>错误示例，在这个例子中，如果我们将这个已经被内联的函数对象进行返回，那么将会出现错误，在右下角实际编译的代码中，我们可以发现，这个函数对象被传递过来了，同时它的代码也被展开替换在此处了，这将导致错误</p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240118171136807.png" alt="image-20240118171136807"></p>
<p>如果我们一定要将这个函数对象作为对象来使用，那么可以为它添加上noinline关键字，此时该对象就不会参与内联</p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240118171359716.png" alt="image-20240118171359716"></p>
<h3 id="增强内联crossinline"><a href="#增强内联crossinline" class="headerlink" title="增强内联crossinline"></a>增强内联crossinline</h3><p>1.如果函数未使用内联，那么在lambda表达式处是不允许使用return的，但是可以使用<code>return@inlineTest</code>，这将局部返回，也就是会结束当前函数参数的调用。</p>
<p>2.如果使用了内联，并且使用了return，这会使得函数被内联，代码被展开，return关键字将会结束最外层的函数，如果不想直接结束最外层的函数，那么使用<code>return@inlineTest</code>即可</p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240118171705531.png" alt="image-20240118171705531"></p>
<p>3.当使用inline时，在函数内部创建了匿名内部类或者Lambda，并且在这些实现内部调用了函数参数，此时将提示错误，无法在lambda中使用<code>return</code>和<code>return@lable</code>这两种形式，因为由于是在匿名内部类中间接调用，与外界的联系被切断所以无法使用</p>
<p><strong>原因是lambda可能存在return调用</strong></p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240118174733062.png" alt="image-20240118174733062"></p>
<p><strong>解决方法</strong>：使用crossinline</p>
<p>类似于一个契约，保证不会在lambda中使用return，但是可以使用<code>return@lable</code>进行局部返回</p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240118175641398.png" alt="image-20240118175641398"></p>
<h2 id="泛型和委托"><a href="#泛型和委托" class="headerlink" title="泛型和委托"></a>泛型和委托</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><strong>泛型类</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>:T &#123;</span><br><span class="line">		<span class="keyword">return</span> param</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>:T &#123;</span><br><span class="line">	<span class="keyword">return</span> param	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定泛型上界"><a href="#指定泛型上界" class="headerlink" title="指定泛型上界"></a>指定泛型上界</h3><p>此时能传递的类型只能是Number或者Number的子类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Number&gt;</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">		<span class="keyword">return</span> param</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，我们没有指定上界的时候，泛型默认可以为空的，也就是Any?</p>
<p>但是我们可以手动指定</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">T :Any</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写自己的泛型apply方法"><a href="#编写自己的泛型apply方法" class="headerlink" title="编写自己的泛型apply方法"></a>编写自己的泛型apply方法</h3><p>通过泛型的方式，将扩展函数的ClassName指定为T，那么所有的类都可以使用这个扩展函数了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">build</span><span class="params">(block:<span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>:T &#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类委托和委托属性"><a href="#类委托和委托属性" class="headerlink" title="类委托和委托属性"></a><strong>类委托和委托属性</strong></h3><p>委托是一种设计模式，基本理念是：操作对象自己不会去处理某段逻辑，而是会把工作委托给另外一个辅助对象去处理。</p>
<p>Kotlin中有两种</p>
<ul>
<li>类委托</li>
<li>属性委托</li>
</ul>
<h3 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h3><p>核心思想在于将一个类的具体实现委托给另外一个类去完成</p>
<p>比如下面这个类，我们将它实现Set接口，那么理所当然需要实现它的抽象方法，此时我们使用另外一个辅助对象去实现，然后我们可以在这些方法里面进行修改，以满足自己的要求，这实际上也是一种委托模式。但是比较麻烦。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySet</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = helperSet.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span> = helperSet.contains(element)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span> = helperSet.containsAll(elements)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span> = helperSet.isEmpty()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span> = helperSet.iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免实现成百上千的个抽象方法，我们可以使用Kotlin里面的by关键字，此时我们可以实现想修改的方法，或者添加自己独有的方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySet</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; <span class="keyword">by</span> helperSet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">helloWorld</span><span class="params">()</span></span> = println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语法规则:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">T</span>&gt; (<span class="keyword">val</span> helperClass: HelperClass&lt;T&gt;) : Class&lt;T&gt; <span class="keyword">by</span> helperClass &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><p>核心思想在于将一个属性的具体实现委托给另外一个类去实现</p>
<p>语法结构</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Delegate类</strong></p>
<p>参数1：表示声明该类的委托功能在可以在什么类中使用</p>
<p>参数2：是Kotlin中的一个属性操作类，可以获取各种属性相关的值。**&lt;*&gt;**这种泛型的写法表示不知道或者不关心泛型的具体类型，有点类似于Java中的&lt;?&gt;</p>
<p>参数3：表示具体要委托属性的值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> propValue: Any? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(myClass: <span class="type">MyClass</span>, prop: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">return</span> propValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(myClass: <span class="type">MyClass</span>, prop: <span class="type">KProperty</span>&lt;*&gt;, value:<span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        propValue = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给p属性赋值就调用setValue，获取就调用getValue</p>
<p>如果p使用val，那么可以不用实现setValue</p>
<blockquote>
<p>需要注意operator和override的区别</p>
<p><code>operator</code> 关键字用于重载一些特定的操作符，例如 <code>+</code>、<code>-</code>、<code>*</code> 等，或者特定的函数调用操作，如属性访问操作 <code>getValue</code> 和 <code>setValue</code>。</p>
<p><code>override</code> 关键字用于表明你正在重写（覆盖）一个父类或接口的成员（方法、属性等）</p>
</blockquote>
<h3 id="lazy函数的实现"><a href="#lazy函数的实现" class="headerlink" title="lazy函数的实现"></a>lazy函数的实现</h3><p>lazy实际上是一个高阶函数，在lazy函数中会创建一个Delegate对象，当我们调用p属性的时候，其实调用的是Delegate对象的getValue()方法，getValue()方法中又会调用lazy中传入的Lambda表达式，p属性最后得到的值就是lambda表达式中最后一行代码的返回值。</p>
<p>创建一个Later类，在该类中我们使用operator重载了getValue访问器，在该访问器中我们判断了value是否为空，如果为空就调用lambda表达式（也就是传递进来的函数参数）去给value赋值，最后将value强制转换为T类型，也就是Lambda的返回类型，完成赋值取值操作，可以理解为这是单例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Later</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> block: () -&gt; T) &#123;</span><br><span class="line">    <span class="keyword">var</span> value: Any? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(any: <span class="type">Any</span>?, prop: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            value = block()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用中我们可以发现，只有第一次调用会打印，在这里我们需要使用val，因为我们没有重载setValue方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p <span class="keyword">by</span> later &#123;</span><br><span class="line">    println(<span class="string">&quot;懒加载开始&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">    builder.apply &#123;</span><br><span class="line">        append(<span class="string">&quot;11&quot;</span>)</span><br><span class="line">        append(<span class="string">&quot;12&quot;</span>)</span><br><span class="line">        append(<span class="string">&quot;13&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这只是大致还原，lazy高阶函数还有同步、空值处理等方面的实现。</p>
<h2 id="Infix函数"><a href="#Infix函数" class="headerlink" title="Infix函数"></a>Infix函数</h2><p>对于Infix函数，只是把函数调用的语法规则进行了调整，比如<code>A.to(B)</code>，那么使用Infix函数就可以是 <code>A to B</code></p>
<p>使用Infix函数有两个限制</p>
<ol>
<li>infix函数是不能定义成顶层函数的，它必须是某个类的成员函数，可以使用扩展函数的方式将它定义到某个类型中</li>
<li>infix函数只能接收一个参数，类型无限制（因为一个参数才能满足上面那么语法规则）</li>
</ol>
<p>比如我们可以定义下面这个infix函数，他为Collection接口添加了一个has函数，那么所有的实现了Collection接口的类都可以调用这个has函数，实际上就是调用了contains函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">has</span><span class="params">(element:<span class="type">T</span>)</span></span> = contains(element)</span><br></pre></td></tr></table></figure>

<p>我们在mapOf里使用了A to B这样的语法，实际上就可以这样来写infix函数，只不过需要修改为A with B</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A,B&gt;</span> A.<span class="title">with</span><span class="params">(that:<span class="type">B</span>)</span></span> = Pair&lt;A,B&gt;(<span class="keyword">this</span>, that)</span><br></pre></td></tr></table></figure>

<h2 id="泛型实化"><a href="#泛型实化" class="headerlink" title="泛型实化"></a>泛型实化</h2><h3 id="实化"><a href="#实化" class="headerlink" title="实化"></a>实化</h3><p>我们可以通过结合内联函数，直接可以获取到泛型的实际类型，因为当声明为内联函数时，函数中的代码将会被替换到调用处，从而避免了类型被擦除。</p>
<p>从下图可以看见，当被替换后，foo函数可以获取到实际的类型String</p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240127173347979.png" alt="image-20240127173347979"></p>
<p>在声明泛型的地方，添加上reified关键字即可，同时方法需要声明为inline内联函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getGenericType</span><span class="params">()</span></span>:Class&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> T::<span class="keyword">class</span>.java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用即可获取实际类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(getGenericType&lt;<span class="built_in">Int</span>&gt;())</span><br></pre></td></tr></table></figure>

<p>比如我们在Android中启动其他活动，那么我们可以通过上面的方法简化调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Context.<span class="title">startActivity</span><span class="params">(block: <span class="type">Intent</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, T::<span class="keyword">class</span>.java)</span><br><span class="line">    intent.block()</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先将这个方法声明为一个内联的泛型实化方法，并且将它扩展为Context的方法，在参数列表中，我们传递了一个函数类型，为Intent的扩展方法，为了使用Intent传递参数</p>
<p>就可以这样调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity&lt;ThirdActivity&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h3><h4 id="类型转换安全隐患"><a href="#类型转换安全隐患" class="headerlink" title="类型转换安全隐患"></a>类型转换安全隐患</h4><p>当前我们有一个父类<code>Person</code>，两个子类<code>Student</code> <code>Teacher</code> 如果某个方法接收一个<code>Person</code>参数，那么传递两个子类都是可行的，但是如果是<code>List&lt;Person&gt;</code> 那么在Java中是不允许这样做的，<code>List&lt;Student&gt;</code>是无法转为<code>List&lt;Person&gt;</code>的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) : Person(name = <span class="string">&quot;tom&quot;</span>, age) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, name, age) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;DefaultName&quot;</span>, <span class="number">12</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(name: String = <span class="string">&quot;jack&quot;</span>, age: <span class="built_in">Int</span> = <span class="number">0</span>) : Person(name, age)</span><br></pre></td></tr></table></figure>

<p>然后我们再创建一个SimpleData类用于获取和修改数据，这是一个泛型类，并且<code>set</code>允许传递一个泛型参数对data进行赋值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">data</span>: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(t: <span class="type">T</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span> = t</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再单独创建一个方法，用于修改<code>SimpleData</code>中的data数据，我们将传递进来的Simpledata对象的data属性设置一个Teacher对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleSimpleData</span><span class="params">(simpleData: <span class="type">SimpleData</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> teacher = Teacher()</span><br><span class="line">    simpleData.<span class="keyword">set</span>(teacher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时如果我们编写如下代码将会提示错误，原因为类型不匹配，这也就证明了在Java中是不允许这样做的（目前的代码和Java无异）。因为如果接下来我们调用get方法的时候，由于Simpledata是Student类型，通过get方法也应该返回Student类型，但是此时data为Teacher类型，必然会导致类型转换异常。</p>
<blockquote>
<p>总结：也就是说在某个地方可能发生对泛型对象内部属性进行修改的情况，会导致在之后的取值中出现类型转换异常，因此是禁止的这种形式的。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> simpleData = SimpleData&lt;Student&gt;()</span><br><span class="line">simpleData.<span class="keyword">set</span>(Student())</span><br><span class="line">handleSimpleData(simpleData)</span><br><span class="line">println(simpleData.<span class="keyword">get</span>())</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240127195914644.png" alt="image-20240127195914644"></p>
<h4 id="In位置和Out位置约定"><a href="#In位置和Out位置约定" class="headerlink" title="In位置和Out位置约定"></a>In位置和Out位置约定</h4><p>此时我们约定一个泛型类或者泛型接口中的方法，入参为<code>in</code>位置 返回值为<code>out</code>位置，如图所示</p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240127200251145.png" alt="image-20240127200251145"></p>
<h4 id="协变-使用Kotlin关键字Out解决安全隐患"><a href="#协变-使用Kotlin关键字Out解决安全隐患" class="headerlink" title="协变-使用Kotlin关键字Out解决安全隐患"></a>协变-使用Kotlin关键字Out解决安全隐患</h4><p>此时我们为泛型类SimpleData的泛型类型前添加关键字out，表示现在T只能出现在Out位置，也就是只能被获取，不可被修改。</p>
<blockquote>
<p>注意，需要使用<code>val</code>关键字，表示不可被修改，或者使用private var只能在内部修改</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">out T</span>&gt;(<span class="keyword">val</span> <span class="keyword">data</span>: T?) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就可以将<code>Simple&lt;Student&gt;</code>类型的对象传递给该方法了，因为我们已经进行了<strong>协变声明</strong>，表示<code>SimpleData&lt;Student&gt;</code>是 <code>SimpleData&lt;Person&gt;</code>的子类，此时在<code>handleMyData()</code>方法中去获取<code>SimpleData</code>封装的数据，虽然这里泛型声明的是 <code>Person</code>类型，实际获得的会是一个<code>Student</code>的实例，但由于<code>Person</code>是<code>Student</code>的父类，向上 转型是完全安全的，所以这段代码没有任何问题。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleSimpleData</span><span class="params">(simpleData: <span class="type">SimpleData</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = simpleData.<span class="keyword">get</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在不可变的List源码中，我们可以发现List也是支持协变的，因为List不支持修改，因此天然支持协变。</p>
<p>但是该接口中我们可以发现一个方法在in位置添加泛型参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>

<p>这是因为contains不会修改List，只是判断集合中是否存在该参数，目的明确。此时使用<code>@UnsafeVariance</code>注解即可忽略错误。</p>
</blockquote>
<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p>假如定义了一个 MyClass的泛型类，其中A是B的子类型，同时MyClass<strong>又是MyClass的子类型， 那么我们就可以称MyClass在T这个泛型上是逆变的。</strong></p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240127211305546.png" alt="image-20240127211305546"></p>
<p>现在我们有如下代码，有一个泛型接口，一个<code>handleTransformer</code>方法，接收一个接口实现类对象，类型为Student，此时我们在main中实现了一个接口实现类，不过泛型类型为Person，此时我们将其传递给<code>handleTransformer</code>方法，但是会提示类型不匹配，因为<code>Transformer&lt;Person&gt;</code>不是<code>Transformer&lt;Student&gt;</code>的子类。但是<code>Person</code>是<code>Student</code>的父类，接口实现类（类型为Person）中的方法只是会返回字符串，对于Student也是完全可以正常使用的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> trans  = <span class="keyword">object</span> :Transformer&lt;Person&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(t: <span class="type">Person</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="subst">$&#123;t.name&#125;</span> + <span class="subst">$&#123;t.age&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleTransformer(trans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Transformer</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(t: <span class="type">T</span>)</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleTransformer</span><span class="params">(trans: <span class="type">Transformer</span>&lt;<span class="type">Student</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> result = trans.transform(student)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240127211751389.png" alt="image-20240127211751389"></p>
<p>此时我们可以使用逆变，在泛型接口的泛型类型前面加上<code>in</code>关键字，表示T只能出现在in位置上，不可以出现在out位置上，同时也意味着Transformer在泛型T上是逆变的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Transformer</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(t: <span class="type">T</span>)</span></span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h3><p>之所以不能出现在out位置上，是因为在接口实现中的方法里面，返回了Person的另外一个子类Teacher，因为Teacher是Person的子类，所以是合法的，但是对于同是子类的Student来说，这会出现类型转换异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">val</span> trans  = <span class="keyword">object</span> :Transformer&lt;Person&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(t: <span class="type">Person</span>)</span></span>: Person &#123;</span><br><span class="line">            <span class="keyword">return</span> Teacher()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 为了让编译器通过编译，加上@UnsafeVariance注解</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Transformer</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(t: <span class="type">T</span>)</span></span>: <span class="meta">@UnsafeVariance</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常：</p>
<p><img src="/../../images/Kotlin%E7%AC%94%E8%AE%B0/image-20240127212554872.png" alt="image-20240127212554872"></p>
<p>在Comparable的源码中，我们也可以发现逆变的应用，比如此时Comparable的实现类为Perosn类型，我们依然可以</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line"> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现a不仅能赋值给b，还可以传递给comparable方法，这就是逆变</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> main&#123;</span></span><br><span class="line">    <span class="keyword">val</span> a:Comparable&lt;Person&gt; = Person(<span class="string">&quot;nam&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> b:Comparable&lt;Student&gt; = a</span><br><span class="line">    comparable(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">comparable</span><span class="params">(comparable: <span class="type">Comparable</span>&lt;<span class="type">Student</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;name&quot;</span>, <span class="number">10</span>)</span><br><span class="line">    println(comparable.compareTo(student))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>):Comparable&lt;Person&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Person</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - other.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程可以理解为一种轻量级的线程，协程可以仅在编程语言的层面实现不同协程之间的转换，提高并发变成的运行效率。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>GlobalScope.launch&#123;&#125;</code>会创建一个协程的作用域，创建的是<strong>顶层协程</strong>，lambda表达式中的代码便会在协程中运行。<strong>注意：该函数不会阻塞外部，当外部协程或者线程结束时，该协程将会被关闭</strong></p>
<p>例如：这段代码将不会输出协程内的内容，而是会直接结束。除非你在外部线程或协程中添加一个<code>Thread.sleep()</code>或者<code>delay()</code>进行阻塞等待这个协程执行完毕。但是如果当外部阻塞结束后，内部任务还没有完成，协程同样将会被关闭</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>delay()会把当前协程进行挂起</strong></p>
</blockquote>
<p><code>runBlocking&#123;&#125;</code>函数也会<strong>创建一个协程作用域（同样也是一个协程）</strong>，它保证协程作用域中所有代码和子协程全部执行完毕前<strong>阻塞当前线程或者协程</strong></p>
<blockquote>
<p>对于<code>GlobalScope.launch&#123;&#125;</code>，即使内部使用了<code>runBlocking&#123;&#125;</code>进行阻塞，也是没有作用的，外部线程或协程一旦结束，该协程以及内部子协程也同样会被关闭</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123; </span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope&quot;</span>)</span><br><span class="line">        delay(<span class="number">1500</span>)</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建多个协程</strong></p>
<p>我们可以使用<code>launch</code>函数创建多个协程，下面是创建了两个子协程</p>
<blockquote>
<p>该函数必须要在协程作用域中调用</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123; </span><br><span class="line">            println(<span class="string">&quot;launch1&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;launch1-end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            println(<span class="string">&quot;launch2&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;launch2-end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过运行结果我们可以发现是并发运行的，这两个子协程实际上是运行在同一个线程中，由编程语言决定谁挂起，谁运行，不需要操作系统进行调度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">launch1</span><br><span class="line">launch2</span><br><span class="line">launch1-end</span><br><span class="line">launch2-end</span><br></pre></td></tr></table></figure>

<h3 id="挂起函数-suspend"><a href="#挂起函数-suspend" class="headerlink" title="挂起函数-suspend"></a>挂起函数-suspend</h3><p>当我们把部分代码进行提取到单独的方法中后，会发现<code>delay()</code>挂起函数无法使用。因此我们需要使用<code>suspend</code>关键字声明该函数为挂起函数，而挂起函数之前可以相互调用，因此我们就可以使用<code>delay()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">printDot</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，<code>suspend</code>关键字只是声明为挂起函数，无法提供协程作用域，我们就无法使用<code>launch()</code>函数。</p>
<p><code>coroutineScope</code>函数，该函数将会<strong>继承外部</strong>的协程作用域<strong>并创建一个子协程</strong>，此时我们就可以调用<code>launch()</code>函数了，但是不可以省去<code>suspend</code>关键字，因为当声明了<code>suspend</code>关键字后，这个挂起函数只能由有协程作用域的区域调用，如果去掉后，其他线程就能够调用了，这是不合法的</p>
<p>该函数也会保证作用域内部的所有代码和子协程执行完毕之前，外部协程被一直挂起</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">printDot</span><span class="params">()</span></span> &#123;</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            println(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要去掉<code>suspend</code>关键字，那么只能这段代码提取到外部的协程作用域中，示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        coroutineScope &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">                    println(i)</span><br><span class="line">                    delay(<span class="number">500</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;coroutineEnd&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;runBlockingEnd&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个函数都会保证所有代码和子协程执行完毕</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">coroutineEnd</span><br><span class="line">runBlockingEnd</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p><strong>coroutineScope和runBlocking差异</strong></p>
<ul>
<li><p>coroutineScope只会阻塞当前协程，既不会影响其他协程，也不会影响任何线程</p>
<p>从下面这个例子就可以看出，我们在<code>runBlocking</code>中创建了一个外部协程(<code>runBlocking</code>中启动)和一个内部协程(<code>coroutineScope</code>中启动)，当外部协程阻塞时，将会运行内部协程，当内部协程阻塞时，将会运行外部协程，从运行结果可知。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        printDot()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">printDot</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Start of the program&quot;</span>)</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            println(<span class="string">&quot;External coroutine running in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;External coroutine completed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        coroutineScope &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                println(<span class="string">&quot;Internal coroutine running in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">                delay(<span class="number">2000</span>)</span><br><span class="line">                println(<span class="string">&quot;Internal coroutine completed&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;End of the program&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Start of the program</span><br><span class="line">External coroutine running <span class="keyword">in</span> thread: main</span><br><span class="line">Internal coroutine running <span class="keyword">in</span> thread: main</span><br><span class="line">External coroutine completed</span><br><span class="line">Internal coroutine completed</span><br><span class="line">End of the program</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>runBlocking函数会挂起外部线程，如果恰恰在主线程中调用，可能导致界面卡死</p>
</li>
</ul>
<h3 id="更多的作用域构建器"><a href="#更多的作用域构建器" class="headerlink" title="更多的作用域构建器"></a>更多的作用域构建器</h3><blockquote>
<p>在 Kotlin 协程中，所有的协程构建器都会创建协程</p>
</blockquote>
<table>
<thead>
<tr>
<th>构建器</th>
<th>说明</th>
<th>调用位置</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><strong>GlobalScope.launch{}</strong></td>
<td>创建顶层协程、协程作用域、非阻塞</td>
<td>任意</td>
<td>Job</td>
</tr>
<tr>
<td><strong>runBlocking{}</strong></td>
<td>创建顶层协程、协程作用域、阻塞</td>
<td>任意</td>
<td>T(末尾表达式)</td>
</tr>
<tr>
<td><strong>launch{}</strong></td>
<td>继承父作用域、非阻塞（不会影响其他协程运行）、构建子协程</td>
<td>协程作用域</td>
<td>Job</td>
</tr>
<tr>
<td><strong>coroutineScope{}</strong></td>
<td>阻塞（但不阻塞外部协程和线程）</td>
<td>协程作用域、挂起函数</td>
<td>T(内部协程返回结果集合)</td>
</tr>
<tr>
<td><strong>CoroutineScope(job)</strong></td>
<td>阻塞（但不阻塞外部协程和线程）</td>
<td>任意</td>
<td>协程作用域对象</td>
</tr>
<tr>
<td><strong>async{}</strong></td>
<td>继承父作用域、非阻塞（不会影响其他协程运行，除非调用返回对象的await()）、构建子协程</td>
<td>协程作用域、挂起函数</td>
<td>Deferred对象</td>
</tr>
<tr>
<td><strong>withContext()</strong></td>
<td>继承父作用域、阻塞、构建子协程</td>
<td>协程作用域、挂起函数</td>
<td>T(末尾表达式)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>调用位置</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>suspendCoroutine</td>
<td>无协程作用域、阻塞</td>
<td>协程作用域、挂起函数</td>
<td>T（resume返回结果）</td>
</tr>
</tbody></table>
<p>对于构建器返回的<code>Job</code>对象，我们可以进行取消</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：由于使用顶层协程GlobalScope.launch函数导致，如果Activity已经关闭，而协程内部的网络请求还未结束，此时回调也无意义，因此需要取消。并且如果有多个顶层协程，那我们就需要手动去依次关闭，这是无法维护的</p>
<p><strong>因此我们要避免使用顶层协程</strong></p>
</blockquote>
<p><strong>常用的方法</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">jobCancelTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> job = Job()</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(job)</span><br><span class="line">    scope.launch &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    job.cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过这种形式来创建一个<code>Job</code>对象，并将其放到<code>CoroutineScope()</code>函数中，注意这是一个函数，虽然它首字母为大写。将会返回一个CoroutineScope对象，这个 <code>CoroutineScope</code> 对象将作为协程的作用域，管理在其范围内启动的协程。</p>
<p>我们通过调用该对象的<code>launch&#123;&#125;</code>函数即可启动协程。不管协程作用域中是否有多个协程，我们都可以调用<code>job.cancel()</code>将其全部取消。</p>
<blockquote>
<p>注意，这里使用scope.launch{}函数启动的协程都被关联在Job对象的作用域之下</p>
<p>多个与job关联的协程是指，<code>scope.launch&#123;&#125;</code>启动的协程</p>
</blockquote>
<p><strong>结合到Android中使用</strong></p>
<p>我们使用两个按键就可以去控制任务的取消与启动，通过<code>job.isCompleted</code>判断任务是否已经完成</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">binding.button.setOnClickListener &#123;</span><br><span class="line">    job = jobCancelTest()</span><br><span class="line">&#125;</span><br><span class="line">binding.button4.setOnClickListener &#123;</span><br><span class="line">    job.isCompleted.let &#123;</span><br><span class="line">        <span class="keyword">if</span> (!it) &#123;</span><br><span class="line">            job.cancel()</span><br><span class="line">            Log.i(tag, <span class="string">&quot;任务取消&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">jobCancelTest</span><span class="params">()</span></span>: Job &#123;</span><br><span class="line">       <span class="keyword">val</span> job = Job()</span><br><span class="line">       <span class="keyword">val</span> scope = CoroutineScope(job)</span><br><span class="line">       scope.launch &#123;</span><br><span class="line">           <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">               Log.i(tag, <span class="string">&quot;jobCancelTest: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">               runOnUiThread &#123;</span><br><span class="line">                   binding.textView.text = i.toString()</span><br><span class="line">               &#125;</span><br><span class="line">               delay(<span class="number">300</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> job</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取协程的返回结果"><a href="#获取协程的返回结果" class="headerlink" title="获取协程的返回结果"></a>获取协程的返回结果</h3><p><code>async&#123;&#125;</code>函数，该函数需要在协程作用域中使用，并且会创建一个子协程以及返回一个<code>Deferred</code>对象</p>
<p>使用<code>async&#123;&#125;</code>函数时，不会阻塞其他的协程，比如下面的例子，将会是交替输出</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">    async &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">            println(i)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    async &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">101.</span><span class="number">.200</span>) &#123;</span><br><span class="line">            println(i)</span><br><span class="line">            delay(<span class="number">300</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>阻塞串行获取返回值</strong></p>
<p>上面是非阻塞的使用，如果我们想要获取协程体内返回的数据，那么需要使用<code>await()</code>函数，该函数由<code>async&#123;&#125;</code>函数返回的<code>Deferred</code>调用，下面的协程体中即使调用了<code>delay()</code>也无法让其他协程进行工作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">    async &#123;</span><br><span class="line">        println(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;.await()</span><br><span class="line">    async &#123;</span><br><span class="line">        println(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>阻塞并行获取返回值</strong></p>
<p>我们只需要同时调用两个<code>Deferred</code>对象的<code>await</code>函数即可实现并行运行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred1 = async &#123;</span><br><span class="line">        println(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> deferred2 = async &#123;</span><br><span class="line">        println(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;result is <span class="subst">$&#123;deferred1.await()&#125;</span> + <span class="subst">$&#123;deferred2.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用WithContext"><a href="#使用WithContext" class="headerlink" title="使用WithContext()"></a>使用WithContext()</h3><p><code>withContext()</code>函数是一个挂起函数，该函数将会开启一个子协程，并且能返回结果，可以理解为<code>async</code>函数的简化版写法。但是不同的是需要提供一个线程参数，原因如下：</p>
<blockquote>
<p>协程是一种轻量级线程的概念，一个线程可以开启多个协程执行异步任务，但是在Android中网络请求必须在子线程中进行，所以我们不可以在UI线程中开启协程去执行网络请求，这会导致错误，所以需要使用线程参数，用于切换线程</p>
<p>有3种可选值</p>
<ul>
<li>Dispatchers.Default：默认低并发的线程策略</li>
<li>Dispatchers.IO：较高并发的线程策略，如执行网络请求，执行的代码大多数时间为阻塞和等待</li>
<li>Dispatchers.Main：不会开启子线程，在UI线程中执行，该参数只能在Android中使用</li>
</ul>
<p>实际上除了coroutineScope函数外，其他的都可以指定线程参数，只不过withContext是强制要求指定</p>
<p>在上面的jobCancelTest()函数中，我们使用<code>scope.launch&#123;&#125;</code>开启协程的时候，实际上使用了默认调度器，因此它在默认调度器的工作线程上执行</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = withContext(Dispatchers.Default) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        <span class="number">5</span> + <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简化网络请求回调"><a href="#简化网络请求回调" class="headerlink" title="简化网络请求回调"></a>简化网络请求回调</h3><p>在Android基础知识点中，我们使用的是匿名类来实现回调机制的，我们可以使用协程来进行优化简洁调用代码</p>
<p><code>suspendCoroutine&#123;&#125;</code>函数，该函数必须在协程作用域中或者挂起函数中调用，接收一个lambda表达式参数，主要作用为将当前协程立即挂起，然后在一个普通的线程中执行lambda表达式中的代码。</p>
<p>调用<code>resume()</code>和<code>resumeWithException()</code>可使协程恢复执行，并返回传递的参数</p>
<p><strong>简化请求：</strong></p>
<p>在这里我们使用<code>suspendCoroutine&#123;&#125;</code>函数，在内部调用了<code>NetworkRequest.sendRequestWithHttpUrl</code>方法完成封装，并对匿名类中携带的结果进行返回</p>
<blockquote>
<p>注意，实际上这里我们只是对网络请求的调用进行了封装，实际上还是使用了最基础的网络通信方法，即<code>sendRequestWithHttpUrl</code>或者<code>sendRequestWithOkHttp</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">(address: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        NetworkRequest.sendRequestWithHttpUrl(address, <span class="keyword">object</span> : HttpCallbackListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(response: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                continuation.resume(response)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Exception</span>)</span></span> &#123;</span><br><span class="line">                continuation.resumeWithException(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">(address: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        NetworkRequest.sendRequestWithOkHttp(address, <span class="keyword">object</span> : Callback &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">                continuation.resumeWithException(e)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">                continuation.resume(response.body?.string().toString())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简化retrofit网络请求（网络通信函数简化）</strong></p>
<p>主要思路：查看原先的调用，可以发现主要是对<code>service.getAppData()</code>返回的<code>Call&lt;List&lt;App&gt;&gt;</code>接口进行调用的<code>enqueue</code>函数，那么我们为<code>Call&lt;List&lt;App&gt;&gt;</code>接口添加一个扩展函数，在扩展函数中调用<code>enqueue</code>，并使用<code>suspendCoroutine</code>进行返回</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> service = ServiceCreator.create&lt;AppService&gt;()</span><br><span class="line"></span><br><span class="line">service.getAppData().enqueue(<span class="keyword">object</span> : retrofit2.Callback&lt;List&lt;App&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        call: <span class="type">retrofit2</span>.<span class="type">Call</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        response: <span class="type">retrofit2</span>.<span class="type">Response</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> list = response.body()</span><br><span class="line">        list?.let &#123;</span><br><span class="line">            showParseResponse(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">retrofit2</span>.<span class="type">Call</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        showParseResponse(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因此优化后的扩展函数代码如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ServiceCreator &#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Call<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">            enqueue(<span class="keyword">object</span> : retrofit2.Callback&lt;T&gt; &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> body = response.body()</span><br><span class="line">                    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">                        continuation.resume(body)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        continuation.resumeWithException(RuntimeException(<span class="string">&quot;response body is null&quot;</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                    continuation.resumeWithException(t)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用这个扩展方法后就会返回数据集合或者异常对象，因此进行封装</p>
<blockquote>
<p>需要注意，由于showParseResponse()方法中没有切换到主线程，因此在这里手动切换一下</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAppData</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> appList = ServiceCreator.create&lt;AppService&gt;().getAppData().await()</span><br><span class="line">        withContext(Dispatchers.Main) &#123;</span><br><span class="line">            showParseResponse(appList)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    getAppData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现优化后的调用非常简洁，如果我们还需要调用其他接口，只需要新建一个getAppData函数，在其中通过动态代理对象调用不同的接口方法即可，对于匿名类我们就避免了重复编写</p>
<h2 id="Flow流-响应式编程"><a href="#Flow流-响应式编程" class="headerlink" title="Flow流-响应式编程"></a><strong>Flow流-响应式编程</strong></h2><p>使用Flow需要添加3个依赖</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.1&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.6.2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>由于Flow是构建在Kotlin协程基础之上的，因此协程依赖库必不可少。第三项是用来提供协程作用域的，同样必不可少。</p>
<p>如果我们需要实现一个计时器功能</p>
<p>首先需要创建一个MainViewModel，需要注意，由于timeFlow是一个全局变量，一开始就会执行，其他场景可能会出现还没有使用这个timeFlow，就开始计时了。但是在现在这个场景下，没有任何接收端，Flow是不会工作的，通过flow构建函数构建出来的Flow属于Code Flow，也叫做冷流，只有当有接收端情况下才会开始执行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span> :<span class="type">ViewModel</span>()&#123;</span><br><span class="line">    <span class="keyword">val</span> timeFlow = flow&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">var</span> time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            emit(time)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            time++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>emit可以理解为一个数据发送器，在之后实现Flow的coolect方法的时候，需要重写emit方法，就会获得这里传递过去的值。</p>
<p>然后我们通过触发点击事件去收集流中的数据，使用collect函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    lifecycleScope.launch &#123;</span><br><span class="line">        mainViewModel.timeFlow.collect &#123; time -&gt;</span><br><span class="line">            textView.text = time.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Flow的collect函数是一个挂起函数，因此必须在协程作用域或其他挂起函数中才能调用。这里我们借助lifecycleScope启动了一个协程作用域来实现。</p>
<p>当有多个Flow需要collect的时候，这样写就是错误的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    mainViewModel.flow1.collect &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    mainViewModel.flow2.collect &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会导致第二个flow完全不会执行，应该使用launch函数再启动子协程去collect即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        mainViewModel.flow1.collect &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        mainViewModel.flow2.collect &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们在collect函数中添加了其他耗时操作，会导致流速不均匀的情况，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    lifecycleScope.launch &#123;</span><br><span class="line">        mainViewModel.timeFlow.collect &#123; time -&gt;</span><br><span class="line">            textView.text = time.toString()</span><br><span class="line">            delay(<span class="number">3000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将会导致3秒计时器才会更新一次，这样会导致管道中的数据堆积过多，获取到的数据已经过时，因此需要使用collectLatest函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    lifecycleScope.launch &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            mainViewModel.timeFlow.collectLatest &#123;</span><br><span class="line">                textView.text = it.toString()</span><br><span class="line">                delay(<span class="number">3000</span>)</span><br><span class="line">                Log.d(<span class="string">&quot;TAGFlow&quot;</span>, <span class="string">&quot;onCreate: &quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>collectLatest函数只接收处理最新的数据。如果有新数据到来了而前一个数据还没有处理完，则会将前一个数据剩余的处理逻辑全部取消。通过打印日志可以发现，使用collectLatest完全不会打印出日志。</p>
<blockquote>
</blockquote>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">num1andNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span> = operation(num1, num2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">num1andNum2Test2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span> = operation(num1, num2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">plusAndMinus</span><span class="params">(multiplication:(<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>, <span class="keyword">noinline</span> multiplication2: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 非内联的函数类型参数可以传递给其他任何函数</span></span><br><span class="line">    num1andNum2Test2(<span class="number">1</span>,<span class="number">2</span>, multiplication2)</span><br><span class="line">    <span class="comment">// 内联的函数类型参数只允许传递给另外一个内联函数</span></span><br><span class="line">    num1andNum2(<span class="number">1</span>,<span class="number">2</span>,multiplication)</span><br><span class="line">    <span class="comment">// 不允许传递给非内联的函数</span></span><br><span class="line">    num1andNum2Test2(<span class="number">1</span>,<span class="number">2</span>, multiplication)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用DSL构建专有的语法结构"><a href="#使用DSL构建专有的语法结构" class="headerlink" title="使用DSL构建专有的语法结构"></a>使用DSL构建专有的语法结构</h2><p>DSL全称为领域特定语言，可以编写出专有的语法结构。Kotlin中实现DSL有多种方式，比如前面的infix，或者使用高阶函数。</p>
<p>比如我们需要添加依赖库</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;androidx.core:core-ktx:1.12.0&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;androidx.appcompat:appcompat:1.6.1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们创建一个Dependency类，在类中定义一个implementation函数，该类用于管理依赖集合</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> libraries = ArrayList&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">implementation</span><span class="params">(lib: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        libraries.add(lib)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建一个顶层高阶函数dependencies，该函数参数我们实现了Dependency的扩展方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dependencies</span><span class="params">(block: <span class="type">Dependency</span>.() -&gt; <span class="type">Unit</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> dependency = Dependency()</span><br><span class="line">    dependency.block()</span><br><span class="line">    <span class="keyword">return</span> dependency.libraries</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么调用时就可以如下调用，lambda表达式中存在Dependency作用域</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	implementation(<span class="string">&quot;androidx.core:core-ktx:1.12.0&quot;</span>)</span><br><span class="line">	implementation(<span class="string">&quot;androidx.appcompat:appcompat:1.6.1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，这就是使用DSL语法结构添加依赖，比起直接调用Dependency对象的implementation()方法更加直观</p>
<h3 id="实现前端代码Kotlin生成"><a href="#实现前端代码Kotlin生成" class="headerlink" title="实现前端代码Kotlin生成"></a>实现前端代码Kotlin生成</h3><p>比如我们有下面这段代码，观察得知有3个标签，那么我们可以分别对应3个类</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>banana<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>pear<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>grape<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>watermelon<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>td</strong></p>
<p>当调用td的html方法时可以获取td的html代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Td</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">()</span></span> = <span class="string">&quot;\n\t\t&lt;td&gt;<span class="variable">$content</span>&lt;/td&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>tr</strong></p>
<p>由于tr下面还能包含td标签，那么就需要创建一个属性去容纳td标签，使用集合即可</p>
<p>添加一个td高阶函数，当调用时可以在lambda表达式中获取到tr的作用域，将该作用域最后一行返回到td的content属性中，即td的内容，然后将该td标签类添加到集合中；再创建了一个html函数，该函数用于获取tr中所有的td标签内容，进行拼接返回</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> children = ArrayList&lt;Td&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">td</span><span class="params">(block: <span class="type">Td</span>.() -&gt; <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> td = Td()</span><br><span class="line">        td.content = td.block()</span><br><span class="line">        children.add(td)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        builder.append(<span class="string">&quot;\n\t&lt;tr&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (childTag <span class="keyword">in</span> children) &#123;</span><br><span class="line">            builder.append(childTag.html())</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">&quot;\n\t&lt;/tr&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>table</strong></p>
<p>table类和tr类大同小异，只不过由于table中包含的tr，因此需要将tr的内容进行拼接，便形成了一个table的html代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> children = ArrayList&lt;Tr&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">tr</span><span class="params">(block: <span class="type">Tr</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tr = Tr()</span><br><span class="line">        tr.block()</span><br><span class="line">        children.add(tr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        builder.append(<span class="string">&quot;&lt;table&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (childTag <span class="keyword">in</span> children) &#123;</span><br><span class="line">            builder.append(childTag.html())</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">&quot;\n&lt;/table&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简化</strong></p>
<p>使用高阶函数，获取到table的作用域，执行并返回html代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">table</span><span class="params">(block: <span class="type">Table</span>.() -&gt; <span class="type">Unit</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> table = Table()</span><br><span class="line">    table.block()</span><br><span class="line">    <span class="keyword">return</span> table.html()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用的时候还可以使用repeat()函数批量生成</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> htmlCode = table &#123;</span><br><span class="line">    tr &#123;</span><br><span class="line">        td &#123; <span class="string">&quot;apple&quot;</span> &#125;</span><br><span class="line">        td &#123; <span class="string">&quot;banana&quot;</span> &#125;</span><br><span class="line">        td &#123; <span class="string">&quot;orange&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tr &#123;</span><br><span class="line">        td &#123; <span class="string">&quot;pear&quot;</span> &#125;</span><br><span class="line">        td &#123; <span class="string">&quot;grape&quot;</span> &#125;</span><br><span class="line">        td &#123; <span class="string">&quot;watermelon&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repeat(<span class="number">2</span>) &#123;</span><br><span class="line">        tr &#123;</span><br><span class="line">            <span class="keyword">val</span> fruits = listOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;orange&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> (fruit <span class="keyword">in</span> fruits) &#123;</span><br><span class="line">                td &#123;</span><br><span class="line">                    fruit</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>banana<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>pear<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>grape<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>watermelon<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>grape<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>grape<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://migu316.github.io">migu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://migu316.github.io/2023/12/27/Android/Kotlin%E7%AC%94%E8%AE%B0/">https://migu316.github.io/2023/12/27/Android/Kotlin%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://migu316.github.io" target="_blank">Migu'Blog|迷毂</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Kotlin/">Kotlin</a></div><div class="post_share"><div class="social-share" data-image="http://lc-zp9lZZL0.cn-n1.lcfile.com/EgIh7nP97s2Iva0odX4lINSstzjXQGHa/favicon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/27/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/" title="希尔排序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">希尔排序</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/26/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" title="插入排序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">插入排序</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://lc-zp9lZZL0.cn-n1.lcfile.com/EgIh7nP97s2Iva0odX4lINSstzjXQGHa/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">migu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/migu316"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">他或许能成为一个Android开发工程师~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">自定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">2.2.</span> <span class="toc-text">语法糖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">程序的逻辑控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.</span> <span class="toc-text">if条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#when%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.</span> <span class="toc-text">when条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.3.</span> <span class="toc-text">循环语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.</span> <span class="toc-text">类与对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%AC%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">主构造函数和次构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.4.</span> <span class="toc-text">函数的可见性修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%92%8C%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">数据类和单例类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E7%BC%96%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">Lambda编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86"><span class="toc-number">6.1.</span> <span class="toc-text">集合的创建和遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8FAPI"><span class="toc-number">6.2.</span> <span class="toc-text">集合的函数式API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%87%BD%E6%95%B0%E5%BC%8F-API-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">Java 函数式 API 的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E6%A3%80%E6%9F%A5"><span class="toc-number">7.</span> <span class="toc-text">空指针检查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.1.</span> <span class="toc-text">可空类型系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E7%A9%BA%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7"><span class="toc-number">7.2.</span> <span class="toc-text">判空辅助工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-let-%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">使用 let 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%B5%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">字符串内嵌表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">9.</span> <span class="toc-text">函数的参数默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">标准函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">12.</span> <span class="toc-text">延迟初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="toc-number">13.</span> <span class="toc-text">密封类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">扩展函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">15.</span> <span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">16.1.</span> <span class="toc-text">定义高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84apply%E5%87%BD%E6%95%B0"><span class="toc-number">16.2.</span> <span class="toc-text">创建自己的apply函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">16.3.</span> <span class="toc-text">高阶函数的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline"><span class="toc-number">16.4.</span> <span class="toc-text">内联函数inline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E5%86%85%E8%81%94noinline"><span class="toc-number">16.5.</span> <span class="toc-text">关闭内联noinline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E5%86%85%E8%81%94crossinline"><span class="toc-number">16.6.</span> <span class="toc-text">增强内联crossinline</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%A7%94%E6%89%98"><span class="toc-number">17.</span> <span class="toc-text">泛型和委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">17.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">17.2.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%B3%9B%E5%9E%8B%E4%B8%8A%E7%95%8C"><span class="toc-number">17.3.</span> <span class="toc-text">指定泛型上界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E6%B3%9B%E5%9E%8Bapply%E6%96%B9%E6%B3%95"><span class="toc-number">17.4.</span> <span class="toc-text">编写自己的泛型apply方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%A7%94%E6%89%98%E5%92%8C%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7"><span class="toc-number">17.5.</span> <span class="toc-text">类委托和委托属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%A7%94%E6%89%98"><span class="toc-number">17.6.</span> <span class="toc-text">类委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%A7%94%E6%89%98"><span class="toc-number">17.7.</span> <span class="toc-text">属性委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lazy%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">17.8.</span> <span class="toc-text">lazy函数的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Infix%E5%87%BD%E6%95%B0"><span class="toc-number">18.</span> <span class="toc-text">Infix函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E5%8C%96"><span class="toc-number">19.</span> <span class="toc-text">泛型实化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E5%8C%96"><span class="toc-number">19.1.</span> <span class="toc-text">实化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98"><span class="toc-number">19.2.</span> <span class="toc-text">协变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3"><span class="toc-number">19.2.1.</span> <span class="toc-text">类型转换安全隐患</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#In%E4%BD%8D%E7%BD%AE%E5%92%8COut%E4%BD%8D%E7%BD%AE%E7%BA%A6%E5%AE%9A"><span class="toc-number">19.2.2.</span> <span class="toc-text">In位置和Out位置约定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98-%E4%BD%BF%E7%94%A8Kotlin%E5%85%B3%E9%94%AE%E5%AD%97Out%E8%A7%A3%E5%86%B3%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3"><span class="toc-number">19.2.3.</span> <span class="toc-text">协变-使用Kotlin关键字Out解决安全隐患</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%8F%98"><span class="toc-number">19.3.</span> <span class="toc-text">逆变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3"><span class="toc-number">19.4.</span> <span class="toc-text">安全隐患</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">20.</span> <span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">20.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0-suspend"><span class="toc-number">20.2.</span> <span class="toc-text">挂起函数-suspend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="toc-number">20.3.</span> <span class="toc-text">更多的作用域构建器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">20.4.</span> <span class="toc-text">获取协程的返回结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8WithContext"><span class="toc-number">20.5.</span> <span class="toc-text">使用WithContext()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%9B%9E%E8%B0%83"><span class="toc-number">20.6.</span> <span class="toc-text">简化网络请求回调</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flow%E6%B5%81-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">21.</span> <span class="toc-text">Flow流-响应式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8DSL%E6%9E%84%E5%BB%BA%E4%B8%93%E6%9C%89%E7%9A%84%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">23.</span> <span class="toc-text">使用DSL构建专有的语法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81Kotlin%E7%94%9F%E6%88%90"><span class="toc-number">23.1.</span> <span class="toc-text">实现前端代码Kotlin生成</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/20/Android/UI/" title="UI">UI</a><time datetime="2024-02-20T11:11:22.000Z" title="发表于 2024-02-20 19:11:22">2024-02-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/18/Android/SDK%E5%BC%80%E5%8F%91-PermissionX/" title="SDK开发-PermissionX">SDK开发-PermissionX</a><time datetime="2024-02-18T14:26:28.000Z" title="发表于 2024-02-18 22:26:28">2024-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/18/Android/Android%E4%BD%BF%E7%94%A8Gradle%E6%89%93%E5%8C%85/" title="Android使用Gradle打包">Android使用Gradle打包</a><time datetime="2024-02-18T10:26:21.000Z" title="发表于 2024-02-18 18:26:21">2024-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/24/Git/Git%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" title="Git的简单使用">Git的简单使用</a><time datetime="2024-01-24T13:28:08.000Z" title="发表于 2024-01-24 21:28:08">2024-01-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/20/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/" title="平衡二叉树AVL">平衡二叉树AVL</a><time datetime="2024-01-20T12:20:25.000Z" title="发表于 2024-01-20 20:20:25">2024-01-20</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By migu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><br/>
<span><!--<img src="/img/icp.png" style="padding:0px;margin:0px;vertical-align:middle;">*--><img src="http://lc-zp9lZZL0.cn-n1.lcfile.com/Fr5gRilnGPnM3AgQaFMGISO6k3Y0e3zd/icp.png" style="padding:0px;margin:0px;vertical-align:middle;">
<a href="http://www.beian.gov.cn/"  style="color:#ffffff;padding:0px;margin:0px;vertical-align:middle;" target="_blank">渝ICP备2021011273号-1</a>
</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>